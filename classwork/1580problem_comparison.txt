/*
═══════════════════════════════════════════════════════════════════════════════
                    原始代码 vs 修正代码 - 详细对比
═══════════════════════════════════════════════════════════════════════════════
*/

/*
┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题1：leeen() 函数未初始化变量                                              │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   int leeen(char arr[]){
       int le;              // ❌ 未初始化！le 的值是随机的
       while(arr[le]!='\n'){
           le++;
       }
       return le;
   }

   可能的后果：
   - le 可能是 -1、999、0 等任意值
   - 可能访问负数下标 → 访问非法内存
   - 可能访问超大下标 → 访问非法内存
   - 导致 Segmentation Fault（段错误）

✓ 修正方案1（直接修复该函数）：
   int leeen(char arr[]) {
       int le = 0;          // ✓ 初始化为 0
       while (arr[le] != '\n') {
           le++;
       }
       return le;
   }

✓ 修正方案2（更好 - 删除该函数）：
   - 根本不需要这个函数
   - 可以直接用 strlen() 或在 strtok 中处理
   - 减少代码复杂度


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题2：allowed() 函数 - 逻辑反了且未被使用                                   │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   int allowed(char arr[],int k){
       char na[5][30];                // ❌ 分配了但从未初始化
       int len=strlen(arr);
       int y=0,x=0;
       for(int i=0;i<len;i++){
           if(arr[i]==' '){
               y++;
               x=0;
               continue;
           }
           arr[i]=na[y][x];           // ❌❌❌ 逻辑反了！
           x++;
       }
       // ❌ 没有 return 语句（但声明返回 int）
   }

多个问题：
   1. 逻辑反了：应该把 arr 的数据复制到 na，而不是把 na 的数据写到 arr
   2. na 从未初始化就被读取，是垃圾数据
   3. 这个函数的目的不明确
   4. 没有返回值，但声明返回 int
   5. 整个程序中根本不调用这个函数！
   6. na 大小只有 [5][30]，最多5个名字，如果有6个就越界
   7. arr 被破坏，后续代码无法使用

✓ 修正方案：
   - 直接删除这个函数
   - 在主程序中用 strtok 分割字符串（已经这样做了）
   - 在主程序中检查选票的合法性


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题3：没有检查选票的合法性                                                   │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   // 直接统计，不做任何检查
   if(flag==0){
       strcpy(v[peo].name,tmp);
       v[peo].vo++;
       peo++;
   }

后果：
   - ❌ 没有检查候选人数是否超过 K
   - ❌ 没有检查是否有重复的候选人
   - ❌ 没有检查空选票
   - ❌ 所有选票都被计算，包括非法的

✓ 修正代码：
   // 检查1：空选票作废
   if (nameCount == 0) {
       isValid = 0;
   }
   
   // 检查2：超过 K 人作废
   if (nameCount > K) {
       isValid = 0;
   }
   
   // 检查3：有重复候选人作废
   if (isValid) {
       for (int i = 0; i < nameCount && isValid; i++) {
           for (int j = i + 1; j < nameCount; j++) {
               if (strcmp(names[i], names[j]) == 0) {
                   isValid = 0;
                   break;
               }
           }
       }
   }
   
   // 只有有效的选票才计算
   if (isValid) {
       totalVotes++;
       // ... 统计代码 ...
   }


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题4：没有排序候选人                                                         │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   // 统计完成后，直接返回
   for(int j=0;j<i;j++){
       // ... 统计代码 ...
   }
   return 0;  // ❌ 就这样返回了

后果：
   - 候选人没有排序
   - 输出顺序是随机的（按输入顺序）
   - 不符合题目要求（按票数高到低，名字字典序排序）

✓ 修正代码：
   sort(candidates, candidates + candidateCount, compare);
   
   bool compare(const Candidate &a, const Candidate &b) {
       if (a.votes != b.votes) {
           return a.votes > b.votes;
       }
       return strcmp(a.name, b.name) < 0;
   }


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题5：没有输出结果                                                           │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   return 0;  // ❌ 什么都没有输出！

后果：
   - 程序运行完，什么都不打印
   - 用户无法看到结果
   - 完全无法使用

✓ 修正代码：
   // 判断是否有人超过半数
   int half = (N + 1) / 2;
   int hasOverHalf = 0;
   for (int i = 0; i < candidateCount; i++) {
       if (candidates[i].votes >= half) {
           hasOverHalf = 1;
           break;
       }
   }
   
   // 根据情况输出
   if (hasOverHalf) {
       // 情况1：输出所有得票>=半数的候选人
       for (int i = 0; i < candidateCount; i++) {
           if (candidates[i].votes >= half) {
               cout << candidates[i].name << " " << candidates[i].votes << endl;
           } else {
               break;
           }
       }
   } else {
       // 情况2：输出前M位候选人，以及与第M位得票相同的候选人
       if (candidateCount <= M) {
           for (int i = 0; i < candidateCount; i++) {
               cout << candidates[i].name << " " << candidates[i].votes << endl;
           }
       } else {
           int mthVotes = candidates[M - 1].votes;
           for (int i = 0; i < candidateCount; i++) {
               if (candidates[i].votes >= mthVotes) {
                   cout << candidates[i].name << " " << candidates[i].votes << endl;
               } else {
                   break;
               }
           }
       }
   }


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题6：变量名混乱导致逻辑错误                                                 │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码中的变量冲突：
   
   for(int m=0;m<=le;m++){           // ❌ 这个 m 是...什么？
       // ...
   }
   
   其中：
   - 函数参数有 int k（K的值）
   - 循环中有 for(int m=...)（内层循环）
   - 但题目中 M 是输出的前M位
   - 有多个同名变量导致混乱

结果：
   - 代码难以理解
   - 易出现逻辑错误
   - 变量重用造成bug

✓ 修正代码：
   - 使用清晰的变量名
   - 参数 K 用于检查候选人数
   - 参数 M 用于输出前M位
   - 不重用变量名


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题7：循环条件错误导致越界                                                   │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   for(int m=0;m<=le;m++){           // ❌ 应该是 m<le，不是 m<=le
       if(input[j][m]==' ' ||input[j][m]=='\n'){
           // ...
       }
       tmp[x]=input[j][m];
       x++;
   }

问题：
   - m<=le 会访问 input[j][le]，但有效范围是 0 到 le-1
   - input[j][le] 可能是 '\n'，会被当作数据处理
   - 导致最后一个候选人的数据混乱

✓ 修正代码：
   for(int m = 0; m < len; m++){     // ✓ 使用 < 而不是 <=
       // ...
   }
   
   或者用更现代的方法：
   char *token = strtok(lineCopy, " \t");
   while (token != NULL) {
       // 处理每个 token（自动跳过分隔符）
       token = strtok(NULL, " \t");
   }


┌─────────────────────────────────────────────────────────────────────────────┐
│ 问题8：结构体成员初始化不兼容                                                 │
└─────────────────────────────────────────────────────────────────────────────┘

❌ 原始代码：
   typedef struct{
       char name[30]={0};            // ❌ C++11 才支持
       int vo=0;
   }vote;

问题：
   - 如果编译器不支持 C++11，会报错
   - 即使支持，创建 vote v[100] 时，每个元素都要初始化，效率较低

✓ 修正代码：
   typedef struct {
       char name[31];
       int votes;
   } Candidate;
   
   // 创建数组
   Candidate candidates[100];
   
   // 在使用前初始化（或者用 memset）
   memset(candidates, 0, sizeof(candidates));


═══════════════════════════════════════════════════════════════════════════════
【总结表】
═══════════════════════════════════════════════════════════════════════════════

┌──────────┬──────────────────────────┬───────────────────────────────┐
│ 问题编号 │ 原始代码的问题           │ 修正方案                       │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题1    │ leeen() 未初始化         │ int le = 0; 或删除该函数      │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题2    │ allowed() 逻辑反了       │ 删除该函数，用 strtok 处理    │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题3    │ 没有检查选票合法性       │ 添加三项检查：K人、重复、空   │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题4    │ 没有排序候选人           │ 使用 sort() 按票数和名字排序  │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题5    │ 没有输出结果             │ 添加输出逻辑                  │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题6    │ 变量名混乱               │ 使用清晰的变量名              │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题7    │ 循环条件 <= 导致越界     │ 改为 < 或用 strtok            │
├──────────┼──────────────────────────┼───────────────────────────────┤
│ 问题8    │ 结构体初始化不兼容       │ 删除 ={0} 和 =0，手动初始化  │
└──────────┴──────────────────────────┴───────────────────────────────┘

═══════════════════════════════════════════════════════════════════════════════
*/
